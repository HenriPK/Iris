<html>
	<head>
		<title>
			Iris Renderer
		</title>
		<script src='iris_render.js'></script>
		<script src='game.js'></script>
		<link rel='stylesheet' type='text/css' href='main.css'/>
		<link rel='icon' type='image/ico' href='Iris.ico'/>
		
		<script id="shader-ps" type="x-shader/x-fragment">#version 300 es
			precision mediump float;
			
			out vec4 fragColor;
			
			//uniform float aspect_ratio;
			uniform vec2 resolution;
			
			//Camera Attributes
			uniform vec3 camera_position;
			uniform vec3 camera_size;
			uniform vec3 facing_dir;
			
			//Scene Clear Color
			uniform vec3 clear_color;
			
			//Ray marching constants
			const float min_step = 0.2;
			const int max_stepc = 200;
			
			//Model
			//uniform sampler2D model;
			int model[16] =int[16](1, 4,
								0, 3,
								
								0, 2,
								0, 0,
								
								0, 0,
								0, 1,
								
								0, 0,
								0, 0);
			vec3 model_size = vec3(2.0, 2.0, 2.0);
			
			//Declarations
			vec4 raymarch(vec2 uv);
			vec4 currentColour(vec3 ray);
			vec3 stepCM (in vec3 p, in vec3 direction, in float cell_size);
			//End of declarations
			
			void main(void) {
				
				vec2 uv = gl_FragCoord.xy / resolution - 0.5;
				
				vec4 col = raymarch(uv);
				
				float d = (distance(uv, vec2(0.0, 0.0)));
				
				col.xyz -= d*d*1.5;
				
				fragColor = vec4(col);
			}
			
			float sdf(vec3 ray) {
				
				vec4 as = vec4(0.5, 0.0, 0.0, 0.5);
			
				float cd = abs(ray.x - as.x);
				cd = max(cd, abs(ray.y - as.y));
				cd = max(cd, abs(ray.z - as.z));
				
				//return cd - as.w/2.0;
				return max(cd-as.w/2.0, -4.0 * (distance(ray, as.xyz) - as.w/2.0));
			}
			
			//#define CELLMARCHING
			
			vec4 raymarch(vec2 uv) {
				
				vec3 ray = normalize(vec3(camera_size.z, uv.x * camera_size.x, uv.y * camera_size.y));
				vec3 photon = camera_position;
				float dist = 0.0;
				
				for(int step = 0; step < max_stepc; step++)
				{
					vec4 col = currentColour(photon); 
					if (col.a < 1.0)
					{
						#ifdef CELLMARCHING
							photon += stepCM(photon, ray, 1.0);
						#else
							photon += ray * min_step;
						#endif
						continue;
					}
					
					return col;
				}
				
				return vec4(clear_color, 1.0);
			}
			
			vec4 currentColour(vec3 r)
			{
				vec4 col = vec4(0.2, 0.4, 0.5, 1.0);
			
				vec3 ray = r;
			
				if (ray.x < 0.0 || ray.y < 0.0 || ray.z < 0.0 || ray.x > model_size.x || ray.y > model_size.y || ray.z > model_size.z)
				{
					return vec4(0.0);
				}
				
				int i = model[int(floor(ray.x) + floor(ray.y) * 2.0 + floor(ray.z) * 4.0)];
				
				if (i == 0) return vec4(0.0);
				if (i == 1) return vec4(0.2, 0.5, 0.1, 1.0);
				if (i == 2) return vec4(0.7, 0.1, 0.3, 1.0);
				if (i == 3) return vec4(0.4, 0.3, 0.6, 1.0);
				if (i == 5) return vec4(0.9, 0.7, 0.8, 1.0);
				return col;
			}
			
			vec3 stepCM (in vec3 p, in vec3 direction, in float cell_size)
			{
				//First determine the cell this point is in.
				//A pair of vectors (minp and maxp)
				
				//return min_step;
				
				/**/
				vec3 minp = floor(p / cell_size) * cell_size;
				vec3 maxp = minp + cell_size;
				
				vec3 dist = vec3(	direction.x > 0. ? maxp.x - p.x : -minp.x + p.x,
									direction.y > 0. ? maxp.y - p.y : -minp.y + p.y,
									direction.z > 0. ? maxp.z - p.z : -minp.z + p.z
								 );
				
				if (abs(direction.z / direction.x) > abs(dist.z / dist.x))
					return dist.z * vec3(direction.x / direction.z, direction.y / direction.z, 1.) + min_step * direction;
				if (abs(direction.y / direction.x) > abs(dist.y / dist.x))
					return dist.y * vec3(direction.x / direction.y, 1., direction.z / direction.y) + min_step * direction;
				return dist.x * vec3(1., direction.y / direction.x, direction.z / direction.x) + min_step * direction;
				/**/
				
			}
		</script>
		
		<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
			in vec3 aVertexPosition;
			uniform float aspect_ratio;
			uniform float time;

			void main(void) {
				
				gl_Position = vec4(aVertexPosition, 1.0);
				//gl_Position = vec4(sin(time) * 0.6, 0.0, 0.0, 0.0) + vec4(aVertexPosition * vec3(1.0, aspect_ratio, 1.0), 1.0);
			}
		</script>
	</head>
	<body onload='init()'>
		<img id='logo' src='Iris.ico'/>
		<h1>
			Iris Renderer
		</h1>
		<canvas id="canvas" width='320' height='180'>
			This device does not support OpenGL.
		</canvas>
		<p>Use Arrow Keys to Move, SPACE and SHIFT to fly.
			Terrible controls, I know.</p>
	</body>
</html>